/*
 * This file was generated by the OEM can_api (/common/can_api/c_generator.py)
 */

#include "{{ header_file }}"
#include <util/atomic.h>
#include "stm32g4xx_hal_fdcan.h"

/*
 * Declare handle for FDCAN1 peripheral
 */
FDCAN_HandleTypeDef hfdcan1; 

/*
 * Configure the FDCAN1 initialization struct and initialize the peripheal.
 */
hfdcan1.Instance = FDCAN1; // Use FDCAN1
hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1; // Divide kernel clock by 1 (no divider)
hfdcan1.Init.FrameFormat = FDCAN_FRAME_CLASSIC; // Use Classic CAN frame standard
hfdcan1.Init.AutoRetransmission = DISABLE;
hfdcan1.Init.TransmitPause = DISABLE;
hfdcan1.Init.ProtocolException = DISABLE;
hfdcan1.Init.NominalPrescaler = 1; // CAN bit timing. See documentation
hfdcan1.Init.NominalSyncJumpWidth = 2; // CAN bit timing. See documentation
hfdcan1.Init.NominalTimeSeg1 = 27; // CAN bit timing. See documentation
hfdcan1.Init.NominalTimeSeg2 = 4; // CAN bit timing. See documentation
hfdcan1.Init.DataPrescaler = 1; // Not used in Classic CAN
hfdcan1.Init.DataSyncJumpWidth = 1; // Not used in Classic CAN
hfdcan1.Init.DataTimeSeg1 = 1; // Not used in Classic CAN
hfdcan1.Init.DataTimeSeg2 = 1; // Not used in Classic CAN
hfdcan1.Init.Mode = FDCAN_MODE_NORMAL; // Normal operating mode
hfdcan1.Init.StdFiltersNbr = {{rx_messages|length}}; // Number of (standard length) message ID filters
hfdcan1.Init.ExtFiltersNbr = 0; // Number of (extended length) message ID filters
hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION; // Use FIFO mode
HAL_FDCAN_Init(&hfdcan1);

/*
 * Receive messages
 *
 * For each message:
 * - Configure reception (RX) filters. Defines which message IDs we care about 
 * and should recieve
 * - Apply configured filter to CAN peripheral
 * - Create an empty struct which cantools will add signals to
 * - Define function implementation for can_poll_receive_(message)
 * - Define function implementation for can_receive_(message)
 */
{% for message in rx_messages %}

// Filter config for: {{ message.name|lower }}
FDCAN_FilterTypeDef sFilterConfig_{{ message.name|lower }};
sFilterConfig_{{ message.name|lower }}.IdType = FDCAN_STANDARD_ID;
sFilterConfig_{{ message.name|lower }}.FilterIndex = {{ loop.index0 }}; {# Current index within Jinja loop, starting at 0 #}
sFilterConfig_{{ message.name|lower }}.FilterType = FDCAN_FILTER_MASK; // Classic filter: FilterID1 = filter, FilterID2 = mask
sFilterConfig_{{ message.name|lower }}.FilterConfig = FDCAN_FILTER_TO_RXFIFO0; // Store message in Rx FIFO 0 if filter matches
sFilterConfig_{{ message.name|lower }}.FilterID1 = {{ message.frame_id }}; // Message ID
sFilterConfig_{{ message.name|lower }}.FilterID2 = 0x7FF; // Bitmask set to all 1s -> only accept exact ID match
HAL_FDCAN_ConfigFilter(&hfdcan1, sFilterConfig_{{ message.name|lower }});

struct can_tools_{{ message.name|lower }}_t {{ message.name|lower }} = {0};

int can_poll_receive_{{ message.name|lower }}(void) {
    //TODO
}

int can_receive_{{ message.name|lower }}(void) {
    //TODO
}
{% endfor %}

/*
 * Start the CAN module.
 */
void can_init_{{ node.name }}(void) {
    
}

/*
 * Transmit messages
 */
{% for message in tx_messages %}
uint8_t {{ message.name|lower }}_data[{{ message.length }}] = {0};

can_frame_t {{ message.name|lower }}_msg = {
    .id = {{ message.frame_id }},
    .mob = 0,
    .data = {{ message.name|lower }}_data,
    .dlc = {{ message.length }},
};

volatile struct can_tools_{{ message.name|lower }}_t {{ message.name|lower }} = {0};

void can_send_{{ message.name|lower }}(void) {
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        // We can be sure here that the CAN data struct won't change here

        can_tools_{{ message.name|lower }}_pack(
            {{ message.name|lower }}_data,
            // We can safely discard the volatile qualifier because we are in an
            // ATOMIC block, so the value will not be changed in an ISR
            (const struct can_tools_{{ message.name|lower }}_t*) &{{ message.name|lower }},
            {{ message.length }}
        );
    }

    can_send(&{{ message.name|lower }}_msg);
}

{% endfor %}

/*
 * Receive messages
 */
{% for message in rx_messages %}
uint8_t {{ message.name|lower }}_data[{{ message.length }}] = {0};

can_frame_t {{ message.name|lower }}_msg = {
    .mob = {{ mobs[message.name] }},
    .data = {{ message.name|lower }}_data,
};

can_filter_t {{ message.name|lower }}_filter = {
    .id = {{ message.frame_id }},
    .mask = {{ masks[message.name] }}
};

struct can_tools_{{ message.name|lower }}_t {{ message.name|lower }} = {0};

int can_receive_{{ message.name|lower }}(void) {
    (void)can_receive(&{{ message.name|lower }}_msg, {{ message.name|lower }}_filter);

    return 0;
}

int can_poll_receive_{{ message.name|lower }}(void) {
    int rc = can_poll_receive(&{{ message.name|lower }}_msg);

    if (rc == 0) {
        can_tools_{{ message.name|lower }}_unpack(&{{ message.name|lower }}, {{ message.name|lower }}_msg.data, {{ message.length }});
    }

    return rc;
}

{% endfor %}
